---
title: "Binary Data Example"
author: "Eric Dunipace"
date: "5/7/2019"
output: html_document
---
<style>
p.caption {
  font-size: 0.9em;
  font-style: italic;
  color: grey;
  margin-right: 10%;
  margin-left: 10%;  
  text-align: justify;
}
</style>
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r data, message= FALSE, warning = FALSE, echo=FALSE}
#### Load packages ####
require(SparsePosterior)
require(ggplot2)
require(CoarsePosteriorSummary)
require(rstan)
require(ggsci)
require(doParallel)
require(xtable)
require(dbarts)

rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores()-1)

group.names <- c("Selection","Loc./Scale", "Projection")

#### generate data ####
set.seed(555)
n <- 2^10 # 1024
p <- 21 # must be at least 6
nsamp <- 1000
nlambda <- 100
lambda.min.ratio <- 1e-10
gamma <- 1
pseudo.observations <- 0

#retrieve parameters
target <- get_binary_nonlinear_model()
target$X$corr <- 0.5

X <- target$X$rX(n, target$X$corr, p)
param <- target$rparam() #for non-linear model, not needed
# param <- NULL
Y.list <- target$rdata(n, X, param, method="random.interaction")
Y <- Y.list$Y
prob <- Y.list$prob
param <- Y.list$param

x <- target$X$rX(1, target$X$corr, p)

```
```{r generate new pop, message=FALSE, warning=FALSE, results='hide', echo=FALSE}

Xnew <- matrix(NA, nrow=n, p)
i <- 0
while(i < n) {
  Xnew[i+1,] <- target$X$rX(1, target$X$corr, p)
  if(Xnew[i+1, 2] < 0 & Xnew[i+1, 3] < 0) i <- i + 1
}

dfXnew <- data.frame(Xnew[,-1])
  formula <- formula(paste0("~ .^2 + ", paste0("I(",colnames(dfXnew),"^2)", collapse=" + ")))
  combinationsNew <- model.matrix(formula, data=dfXnew)

  
# param <- target$rparam() #for non-linear model, not needed
Y.listNew <- target$rdata(n, Xnew, param, method="modified.friedman")
Ynew <- Y.listNew$Y
probNew <- Y.listNew$prob
paramNew <- Y.listNew$theta

```
```{r posterior, message = FALSE, warning = FALSE, results="hide", echo=FALSE}
hyperparameters <- list(m0 = NULL, nodes = NULL,
                          L = NULL)
  hyperparameters$m0 <- 5
  hyperparameters$nodes <- p*3
  hyperparameters$L <- 3
  
nthin <- 1
stan_dir <- "../../exec/Stan"
if(!file.exists("posterior.RData")){
  logistic.path <- file.path(stan_dir,"logistic_horseshoe_noQR.stan")
  post.bart <- target$rpost(nsamp, X[,-1], Y, hyperparameters, method="bart", nskip = nsamp*nthin,
                            k = 2, power=2, base= .95, ntree = 200, keepevery = nthin, test=Xnew[,-1])
  invisible(post.bart$model$fit$state)
  
  post.stan <- target$rpost(nsamp, X, Y, hyperparameters, 
                            method="logistic", stan_dir = logistic.path, chains = 1) 
  # should run with multiple chains
  
  dfX <- data.frame(X[,-1])
  formula <- formula(paste0("~ .^2 + ", paste0("I(",colnames(dfX),"^2)", collapse=" + ")))
  combinations <- model.matrix(formula, data=dfX)
  post.stan.full <- target$rpost(nsamp, combinations, Y, hyperparameters, 
                                 method="logistic", stan_dir = logistic.path, chains = 1) 
  # should run with multiple chains
  
  post.gamm <- target$rpost(nsamp, X, Y, hyperparameters, method="gamm", chains = 1)
  
  
  
  gammX <- as.matrix(post.gamm$model$x)
  
  save(post.bart, post.gamm, post.stan, post.stan.full, combinations, gammX, file="posterior.RData")
} else {
  load("posterior.RData")
}
prob <- c(prob)
mse.best.perform <- data.frame(BART = mean((prob - plogis(t(post.bart$eta)))^2),
   'Simple Logistic' = mean((prob - plogis(t(post.stan$eta)))^2),
   'Logistic with Interactions' = mean((prob - plogis(t(post.stan.full$eta)))^2),
   GAMM = mean((prob - plogis(t(post.gamm$eta)))^2))
rownames(mse.best.perform) <- "MSE"

mse.best.perform_logit <- data.frame(BART = mean((qlogis(prob) - (t(post.bart$eta)))^2),
   'Simple Logistic' = mean((qlogis(prob) - (t(post.stan$eta)))^2),
   'Logistic with Interactions' = mean((qlogis(prob) - (t(post.stan.full$eta)))^2),
   GAMM = mean((qlogis(prob) - (t(post.gamm$eta)))^2))
rownames(mse.best.perform_logit) <- "MSE"
```
```{r method_in_sample, message=FALSE, warning=FALSE, cache=FALSE, echo = FALSE}
# penalty.factor.simple <- 1/colMeans(abs(post.stan$theta))
# penalty.factor.full <- 1/colMeans(abs(post.stan.full$theta))
# penalty.factor.gamm <- 1/colMeans(abs(post.gamm$theta))
penalty.factor.simple <- rep(1, ncol(post.stan$theta))
penalty.factor.full <- rep(1, ncol(post.stan.full$theta))
penalty.factor.gamm <- rep(1, ncol(post.gamm$theta))



if( !file.exists("interact_adapt_bart.rds") ) {
  interaction_adapt_bart <- list(
                 selection = W2L1(X=combinations, Y = post.bart$eta, 
                        theta=post.stan.full$theta, penalty="selection.lasso",
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1e4, maxit = 5e2, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.full, method="selection.variable"),
                 # location.scale = W2L1(X=combinations, Y=post.bart$eta, 
                 #        theta=post.stan.full$theta, penalty="mcp.net", alpha=0.99,
                 #        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                 #        infimum.maxit=1e2, maxit = 1e3, gamma = gamma,
                 #        pseudo_observations = pseudo.observations, display.progress = TRUE,
                 #        penalty.factor = penalty.factor.full,
                 #        method="location.scale"),
                 # projection = W2L1(X=combinations, Y=post.bart$eta, 
                 #        theta=post.stan.full$theta, penalty="mcp.net", alpha=0.99,
                 #        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                 #        infimum.maxit=1, maxit = 1e3, gamma = gamma,
                 #        pseudo_observations = pseudo.observations, display.progress = TRUE,
                 #        penalty.factor = penalty.factor.full, method="projection",tol = 1e-3),
                 mcp = W2L1(X=combinations, Y=post.bart$eta, 
                        theta=post.stan.full$theta, penalty="mcp", alpha=0.99,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e3, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.full, method="projection",tol = 1e-3),
                 lasso = W2L1(X=combinations, Y=post.bart$eta, 
                        theta=post.stan.full$theta, penalty="lasso", alpha=1,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e3, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.full, method="projection",tol = 1e-3)
                )
  saveRDS(interaction_adapt_bart, "interact_adapt_bart.rds")
} else {
  interaction_adapt_bart <- readRDS( "interact_adapt_bart.rds")
}
if( !file.exists("interact_adapt_gam.rds") ) {
  interaction_adapt_gam <- list(
                 selection = W2L1(X=combinations, Y = post.gamm$eta, 
                        theta=post.stan.full$theta, penalty="selection.lasso",
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1e4, maxit = 5e2, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.full, method="selection.variable"),
                 # location.scale = W2L1(X=combinations, Y=post.bart$eta, 
                 #        theta=post.stan.full$theta, penalty="mcp.net", alpha=0.99,
                 #        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                 #        infimum.maxit=1e2, maxit = 1e3, gamma = gamma,
                 #        pseudo_observations = pseudo.observations, display.progress = TRUE,
                 #        penalty.factor = penalty.factor.full,
                 #        method="location.scale"),
                 # projection = W2L1(X=combinations, Y=post.gamm$eta, 
                 #        theta=post.stan.full$theta, penalty="mcp.net", alpha=0.99,
                 #        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                 #        infimum.maxit=1, maxit = 1e3, gamma = gamma,
                 #        pseudo_observations = pseudo.observations, display.progress = TRUE,
                 #        penalty.factor = penalty.factor.full, method="projection",tol = 1e-3),
                 mcp = W2L1(X=combinations, Y=post.gamm$eta, 
                        theta=post.stan.full$theta, penalty="mcp", alpha=0.99,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e3, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.full, method="projection",tol = 1e-3),
                 lasso = W2L1(X=combinations, Y=post.gamm$eta, 
                        theta=post.stan.full$theta, penalty="lasso", alpha=1,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e3, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.full, method="projection",tol = 1e-3)
                )
  saveRDS(interaction_adapt_gam, "interact_adapt_gam.rds")
} else {
  interaction_adapt_gam <- readRDS( "interact_adapt_gam.rds")
}
if (!file.exists("simple_adapt_bart.RDS")){
  simple_adapt_bart <- list(
                     selection = W2L1(X=X, Y = post.bart$eta, 
                        theta=post.stan$theta, penalty="selection.lasso",
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1e4, maxit = 1e3, gamma = gamma,
                        pseudo_observations = pseudo.observations, 
                        display.progress = TRUE,
                        penalty.factor = penalty.factor.simple, method="selection.variable"),
                     # location.scale = W2L1(X=X, Y=post.bart$eta, 
                     #    theta=post.stan$theta, penalty="mcp.net", alpha = 0.5,
                     #    nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                     #    infimum.maxit=1e2, maxit = 1e3, gamma = gamma,
                     #    pseudo_observations = pseudo.observations, display.progress = TRUE,
                     #    penalty.factor = penalty.factor.simple,
                     #    method="location.scale"),
                     # mcp = W2L1(X=X, Y=post.bart$eta, 
                     #    theta=post.stan$theta, penalty="mcp.net", alpha = 0.5,
                     #    nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                     #    infimum.maxit=1, maxit = 1e3, gamma = gamma,
                     #    pseudo_observations = pseudo.observations, display.progress = TRUE,
                     #    penalty.factor = penalty.factor.simple, method="projection"),
                     mcp = W2L1(X=X, Y=post.bart$eta, 
                        theta=post.stan$theta, penalty="mcp", alpha = 1,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e3, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.simple, method="projection"),
                     lasso = W2L1(X=X, Y=post.bart$eta, 
                        theta=post.stan$theta, penalty="lasso", alpha = 1,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e3, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.simple, method="projection")
                )
  saveRDS(simple_adapt_bart, "simple_adapt_bart.RDS")
} else {
  simple_adapt_bart <- readRDS("simple_adapt_bart.RDS")
}

if (!file.exists("simple_adapt_gam.RDS")){
  simple_adapt_gam <- list(
                     selection = W2L1(X=X, Y = post.gamm$eta, 
                        theta=post.stan$theta, penalty="selection.lasso",
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1e4, maxit = 1e3, gamma = gamma,
                        pseudo_observations = pseudo.observations, 
                        display.progress = TRUE,
                        penalty.factor = penalty.factor.simple, method="selection.variable"),
                     # location.scale = W2L1(X=X, Y=post.bart$eta, 
                     #    theta=post.stan$theta, penalty="mcp.net", alpha = 0.5,
                     #    nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                     #    infimum.maxit=1e2, maxit = 1e3, gamma = gamma,
                     #    pseudo_observations = pseudo.observations, display.progress = TRUE,
                     #    penalty.factor = penalty.factor.simple,
                     #    method="location.scale"),
                     # projection = W2L1(X=X, Y=post.bart$eta, 
                     #    theta=post.stan$theta, penalty="mcp.net", alpha = 0.5,
                     #    nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                     #    infimum.maxit=1, maxit = 1e3, gamma = gamma,
                     #    pseudo_observations = pseudo.observations, display.progress = TRUE,
                     #    penalty.factor = penalty.factor.simple, method="projection"),
                     mcp = W2L1(X=X, Y=post.gamm$eta, 
                        theta=post.stan$theta, penalty="mcp", alpha = 0.5,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e3, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.simple, method="projection"),
                     lasso = W2L1(X=X, Y=post.gamm$eta, 
                        theta=post.stan$theta, penalty="lasso", alpha = 1,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e3, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.simple, method="projection")
                )
  saveRDS(simple_adapt_gam, "simple_adapt_gam.RDS")
} else {
  simple_adapt_gam <- readRDS("simple_adapt_gam.RDS")
}

# if (!file.exists("gamm_adapt.RDS")){
#   gamm_adapt <- list(
#                      selection = W2L1(X=gammX, Y = post.bart$eta, 
#                         theta=post.gamm$theta, penalty="selection.lasso",
#                         nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
#                         infimum.maxit=1e4, maxit = 1e3, gamma = gamma,
#                         pseudo_observations = pseudo.observations, 
#                         display.progress = TRUE,
#                         penalty.factor = penalty.factor.gamm,
#                         method="selection.variable"),
#                      # location.scale = W2L1(X=gammX, Y=post.bart$eta, 
#                      #    theta=post.gamm$theta, penalty="mcp.net", alpha = 0.5,
#                      #    nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
#                      #    infimum.maxit=1e2, maxit = 1e3, gamma = gamma,
#                      #    pseudo_observations = pseudo.observations, display.progress = TRUE,
#                      #    penalty.factor = penalty.factor.gamm,
#                      #    method="location.scale"),
#                      projection = W2L1(X=gammX, Y=post.bart$eta, 
#                         theta=post.gamm$theta, penalty="mcp.net", alpha = 0.5,
#                         nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
#                         infimum.maxit=1, maxit = 1e3, gamma = gamma,
#                         pseudo_observations = pseudo.observations, display.progress = TRUE,
#                         penalty.factor = penalty.factor.gamm,
#                         method="projection"),
#                      projection2 = W2L1(X=gammX, Y=post.bart$eta, 
#                         theta=post.gamm$theta, penalty="mcp", alpha = 0.5,
#                         nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
#                         infimum.maxit=1, maxit = 1e3, gamma = gamma,
#                         pseudo_observations = pseudo.observations, display.progress = TRUE,
#                         penalty.factor = penalty.factor.gamm,
#                         method="projection"),
#                      projection3 = W2L1(X=gammX, Y=post.bart$eta, 
#                         theta=post.gamm$theta, penalty="lasso", alpha = 1,
#                         nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
#                         infimum.maxit=1, maxit = 1e3, gamma = gamma,
#                         pseudo_observations = pseudo.observations, display.progress = TRUE,
#                         penalty.factor = penalty.factor.gamm,
#                         method="projection")
#                 )
#   saveRDS(gamm_adapt, "gamm_adapt.RDS")
# } else {
#   gamm_adapt <- readRDS("gamm_adapt.RDS")
# }
```

```{r w2 distances, echo = FALSE, warning= FALSE, message= FALSE}
names(interaction_adapt_bart) <- 
  names(simple_adapt_bart) <- 
  names(interaction_adapt_gam) <- 
  names(simple_adapt_gam) <-  c("Selection",
                      # "Loc./Scale",
                         # "MCP Net Projection",
                         "MCP Projection",
                         "Lasso Projection")

w2plot <- list(bart = list (simple=NULL, interaction = NULL),
               gam = list (simple=NULL, interaction = NULL))
if ( !file.exists("w2plot_bin.rds") ) {
  w2plot$bart$simple <- plot.compare(simple_adapt_bart, post.bart$eta, X, t(post.stan$theta), 
                       "w2", c("mean"), parallel = TRUE) 
  # w2plot$interaction <- plot.compare(interaction_adapt, post.bart$eta, 
  #                                    combinations, t(post.stan.full$theta), 
  #                      "w2", c("mean"), parallel = TRUE) 
  w2plot$bart$interaction <- plot.compare(interaction_adapt_bart, post.bart$eta, 
                                     combinations, t(post.stan.full$theta), 
                       "w2", c("mean"), parallel = TRUE) 
  w2plot$gam$simple <- plot.compare(simple_adapt_gam, post.bart$eta, X, t(post.stan$theta), 
                       "w2", c("mean"), parallel = TRUE) 
  # w2plot$interaction <- plot.compare(interaction_adapt, post.bart$eta, 
  #                                    combinations, t(post.stan.full$theta), 
  #                      "w2", c("mean"), parallel = TRUE) 
  w2plot$gam$interaction <- plot.compare(interaction_adapt_gam, post.bart$eta, 
                                     combinations, t(post.stan.full$theta), 
                       "w2", c("mean"), parallel = TRUE) 
  w2plotData <- lapply(w2plot, function(i) lapply(i, function(j) j$data$mean))
  saveRDS( w2plotData, "w2plot_bin.rds" )
  w2plots <- lapply(w2plot, function(i) lapply(i, function(j) j$plot$mean))
} else {
  w2plotData <- readRDS( "w2plot_bin.rds" )
  w2plots <- lapply(w2plotData, function(ll) lapply(ll, function(ww) ggplot(ww, aes(x=nactive, y=dist, color = groups, group=groups )) +
        geom_line() + scale_color_jama() + labs(color ="Method") +
        xlab("Number of active coefficients") + ylab("2-Wasserstein Distance") + theme_bw() +
        scale_x_continuous(expand = c(0, 0)) +
        scale_y_continuous(expand = c(0, 0),
                           limits = c(0, max(ww$dist)*1.1))))
}
```
```{r mse distances, message=FALSE, echo=FALSE, warning=FALSE}
names(interaction_adapt_bart) <- 
  names(simple_adapt_bart) <- 
  names(interaction_adapt_gam) <- 
  names(simple_adapt_gam) <-  c("Selection",
                      # "Loc./Scale",
                         # "MCP Net Projection",
                         "MCP Projection",
                         "Lasso Projection")

mseplot <- list(bart = list (simple=NULL, interaction = NULL),
               gam = list (simple=NULL, interaction = NULL))
if (!file.exists("mseplot_bin.rds")) {
  mseplot$bart$simple <- plot.compare(simple_adapt_bart, prob, X, t(post.stan$theta),
                        "mse", c("mean"), parallel = TRUE, transform = plogis)
  mseplot$bart$interaction <- plot.compare(interaction_adapt_bart, prob, 
                                           combinations, t(post.stan.full$theta), 
                          "mse", c("mean"), parallel = TRUE, transform = plogis)
  mseplot$gam$simple <- plot.compare(simple_adapt_gam, prob, X, t(post.stan$theta),
                        "mse", c("mean"), parallel = TRUE, transform = plogis)
  mseplot$gam$interaction <- plot.compare(interaction_adapt_gam, prob, 
                                          combinations, t(post.stan.full$theta), 
                          "mse", c("mean"), parallel = TRUE, transform = plogis)
  mseplotData <- lapply(mseplot, function(i) lapply(i, function(j) j$data$mean))
  saveRDS( mseplotData, "mseplot_bin.rds" )
  mseplots <- lapply(mseplot, function(i) lapply(i, function(j) j$plot$mean))
  
} else {
  mseplotData <- readRDS("mseplot_bin.rds" )
  mseplots <- lapply(mseplotData, function(dd) lapply(dd, function(mm) ggplot(mm, aes(x=nactive, y=dist, color = groups, group=groups )) +
        geom_line() + scale_color_jama() + labs(color ="Method") +
        xlab("Number of active coefficients") + ylab("MSE") + theme_bw() +
        scale_x_continuous(expand = c(0, 0)) +
        scale_y_continuous(expand = c(0, 0), 
                           limits = c(0,max(mm$dist)*1.1))))
}
```
## Setup
The method can also be used on binary data. We simulate data as follows. 

### Predictors
We can measure variable importance in a variety of settings. Our first example is in a setting with Normally distributed data. We generate $n = `r n`$ predictor variables, $X$, from a Multivariate Normal,
\[ X_i \sim N(0, \Sigma), \] with $\Sigma_{i,i} = 1$ for all $i$ from 1 to $p = `r p-1`.$ The first 20 dimensions of $X$ are correlated, dimensions 21 to 50 are correlated, and dimensions 51 to 100 are corrlated,  with correlations `r target$X$corr`. Thus, $\Sigma$ is block diagonal.

<!-- ### Parameters -->
<!-- We generate parameters as follows -->
<!-- \[ \beta_{0:5} \sim \text{Unif}(0.1,0.2),\] -->
<!-- \[ \beta_{6:10} \sim \text{Unif}(-0.2,-0.1), \] and -->
<!-- \[ \beta_{11:20} \sim \text{Unif}(0,0.05). \] -->

### Outcome
We sample the outcome from a modified Friedman model:
<!-- cos(2 * x3sq + pi/2) -->
<!--     x3term <- ifelse(2 * x3sq > 3/4 * pi, 1,  costerm) -->
<!-- return(1 * sin(\frac{pi}{8}  x[,1] * x[,2] + pi/2) + 2 * x3term  + tanh(-x[,4]) + 0.25 * x[,5]) -->
\[Y_i \sim \text{Bernoulli}(\nu_i) \] with \[\nu_i = \text{logit}^{-1} \left [\sin\left(\frac{\pi}{8}x_{i,1}x_{i,2} + \pi/2 \right) + 2 I \left(x_{i,3}^2 > 3/4 \pi\right) +  2 I \left(x_{i,3}^2 \leq 3/4 \pi \right) \cos\left(2 x_{i,3}^2  + \pi/2\right) + \tanh(-x_{i,4}) + 0.25 x_{i,5}\right].\]

```{r data_echo, echo=TRUE, eval=FALSE}
<<data>>
```

## Posterior Estimation
We use 4 posterior distributions:

1. a Bayesian additive regression tree (BART) model,
2. a simple logistic regression with the main effects of $X$,
3. a more complicated logistic regression with the main effects and all second order interactions, and
4. a generalized additive mixed model (GAMM).

All models are estimated with their software defaults and the logistic regression are estimated with the Finnish horseshoe.



```{r mse_table, echo=FALSE, warning=FALSE, results='asis'}
print(xtable(mse.best.perform, digits=3, caption="MSE of the posterior predictive means from true data generating probabilities"),type = "html", sanitize.colnames.function = function(x) gsub(".", " ",x))
```
Clearly, the GAM model fits best followed by the BART model.

Then we try to adapt our more poorly fitting but more interpretable models to the better fitting BART model.


```{r dist_plot_post_simple, echo=FALSE, message=FALSE, warning=FALSE, fig.height= 4, fig.width=4, out.width="49%", optipng = '-o7', fig.align = "center", fig.show='hold', fig.cap='2-Wasserstein Distance and MSE for the data used to estimate the posterior using the simple logistic regression model.'}
print(w2plots$bart$simple)
print(w2plots$bart$interaction)
```

```{r dist_plot_post_interact,echo=FALSE, message=FALSE, warning=FALSE, fig.height= 4, fig.width=4, out.width="49%", optipng = '-o7', fig.align = "center", fig.show='hold', fig.cap='2-Wasserstein Distance and MSE for the data used to estimate the posterior using the logistic regression model with all two-way interactions.'}
print(mseplots$bart$simple)
print(mseplots$bart$interaction)
```

```{r dist_plot_post_gamm, echo=FALSE, message=FALSE, warning=FALSE, fig.height= 4, fig.width=4, out.width="49%", optipng = '-o7', fig.align = "center", fig.show='hold', fig.cap='2-Wasserstein Distance and MSE for the data used to estimate the posterior using the Generalized Additive Mixed regression model.'}
print(w2plots$gam$simple)
print(w2plots$gam$interaction)
```

```{r dist_plot_post_gamm, echo=FALSE, message=FALSE, warning=FALSE, fig.height= 4, fig.width=4, out.width="49%", optipng = '-o7', fig.align = "center", fig.show='hold', fig.cap='MSE for the data used to estimate the posterior using the Generalized Additive Mixed regression model.'}
print(mseplots$gam$simple)
print(mseplots$gam$interaction)
```

## Using a subset of data
We may be interested in obtaining a better prediction for a subset of data, or a new population, as from a more interpretable model. That is, maybe we want to adapt our interpretable model to our better predicting model---in this case the BART model. As a reminder:
```{r new_echo, eval=FALSE}
<< generate new pop>>
```
```{r generate new pop param, message=FALSE, warning=FALSE, results='hide'}
gammXNew <- mgcv::predict.gam(post.gamm$model$jam, newdata=data.frame(Xnew[,-1]), type="lpmatrix")
# gammXNew <- as.matrix(gammtemp$model$x)

bartetaNew <- qlogis(pnorm(post.bart$model$yhat.test))
```

Then we can try our procedures again 
```{r method_subset_sample, message=FALSE, warning=FALSE, cache=FALSE}
# penalty.factor.simple <- 1/colMeans(abs(post.stan$theta))
# penalty.factor.full <- 1/colMeans(abs(post.stan.full$theta))
# penalty.factor.gamm <- 1/colMeans(abs(post.gamm$theta))
penalty.factor.simple <- rep(1, ncol(post.stan$theta))
penalty.factor.full <- rep(1, ncol(post.stan.full$theta))
penalty.factor.gamm <- rep(1, ncol(post.gamm$theta))

if( !file.exists("interact_adapt_subset.rds") ) {
  interaction_adapt_subset <- list(
                 selection = W2L1(X=combinationsNew, Y = bartetaNew, 
                        theta=post.stan.full$theta, penalty="selection.lasso",
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1e4, maxit = 5e2, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.full, method="selection.variable"),
                 # location.scale = W2L1(X=combinationsNew, Y=bartetaNew, 
                 #        theta=post.stan.full$theta, penalty="mcp.net", alpha=0.99,
                 #        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                 #        infimum.maxit=1e2, maxit = 1e3, gamma = gamma,
                 #        pseudo_observations = pseudo.observations, display.progress = TRUE,
                 #        penalty.factor = penalty.factor.full,
                 #        method="location.scale"),
                 projection = W2L1(X=combinationsNew, Y=bartetaNew, 
                        theta=post.stan.full$theta, penalty="mcp.net", alpha=0.99,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e3, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.full, method="projection",tol = 1e-3),
                 projection2 = W2L1(X=combinationsNew, Y=bartetaNew, 
                        theta=post.stan.full$theta, penalty="mcp", alpha=0.99,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e3, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.full, method="projection",tol = 1e-3),
                 projection3 = W2L1(X=combinationsNew, Y=bartetaNew, 
                        theta=post.stan.full$theta, penalty="lasso", alpha=1,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e3, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.full, method="projection",tol = 1e-3)
                )
  saveRDS(interaction_adapt_subset, "interact_adapt_subset.rds")
} else {
  interaction_adapt_subset <- readRDS( "interact_adapt_subset.rds")
}

if (!file.exists("simple_adapt_subset.RDS")){
  simple_adapt_subset <- list(
                     selection = W2L1(X=Xnew, Y = bartetaNew, 
                        theta=post.stan$theta, penalty="selection.lasso",
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1e4, maxit = 1e3, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.simple, method="selection.variable"),
                     # location.scale = W2L1(X=Xnew, Y=bartetaNew, 
                     #    theta=post.stan$theta, penalty="mcp.net", alpha = 0.5,
                     #    nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                     #    infimum.maxit=1e2, maxit = 1e3, gamma = gamma,
                     #    pseudo_observations = pseudo.observations, display.progress = TRUE,
                     #    penalty.factor = penalty.factor.simple,
                     #    method="location.scale"),
                     projection = W2L1(X=Xnew, Y=bartetaNew, 
                        theta=post.stan$theta, penalty="mcp.net", alpha = 0.5,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e3, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.simple, method="projection"),
                     projection2 = W2L1(X=Xnew, Y=bartetaNew, 
                        theta=post.stan$theta, penalty="mcp", alpha = 0.5,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e3, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.simple, method="projection"),
                     projection3 = W2L1(X=Xnew, Y=bartetaNew, 
                        theta=post.stan$theta, penalty="lasso", alpha = 1,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e3, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.simple, method="projection")
                )
  saveRDS(simple_adapt_subset, "simple_adapt_subset.RDS")
} else {
  simple_adapt_subset <- readRDS("simple_adapt_subset.RDS")
}

if (!file.exists("gamm_adapt_subset.RDS")){
  gamm_adapt_subset <- list(
                     selection = W2L1(X=gammXNew, Y = bartetaNew, 
                        theta=post.gamm$theta, penalty="selection.lasso",
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1e4, maxit = 1e3, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.gamm,
                        method="selection.variable"),
                     # location.scale = W2L1(X=gammXNew, Y=bartetaNew, 
                     #    theta=post.gamm$theta, penalty="mcp.net", alpha = 0.5,
                     #    nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                     #    infimum.maxit=1e2, maxit = 1e3, gamma = gamma,
                     #    pseudo_observations = pseudo.observations, display.progress = TRUE,
                     #    penalty.factor = penalty.factor.gamm,
                     #    method="location.scale"),
                     projection = W2L1(X=gammXNew, Y=bartetaNew, 
                        theta=post.gamm$theta, penalty="mcp.net", alpha = 0.5,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e3, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.gamm,
                        method="projection"),
                     projection2 = W2L1(X=gammXNew, Y=bartetaNew, 
                        theta=post.gamm$theta, penalty="mcp", alpha = 0.5,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e3, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.gamm,
                        method="projection"),
                     projection3 = W2L1(X=gammXNew, Y=bartetaNew, 
                        theta=post.gamm$theta, penalty="lasso", alpha = 1,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e3, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.gamm,
                        method="projection")
                )
  saveRDS(gamm_adapt_subset, "gamm_adapt_subset.RDS")
} else {
  gamm_adapt_subset <- readRDS("gamm_adapt_subset.RDS")
}
```

```{r w2 distances new}
names(interaction_adapt_subset) <- names(simple_adapt_subset) <- names(gamm_adapt_subset) <- c("Selection",
                              # "Loc./Scale",
                              "MCP Net Projection",
                              "MCP Projection",
                              "Lasso Projection")
w2plot_subset <- list(simple=NULL,
               interaction = NULL, 
               gamm = NULL)
if ( !file.exists("w2plot_bin_subset.rds") ) {
  w2plot_subset$simple <- plot.compare(simple_adapt_subset, bartetaNew, Xnew, t(post.stan$theta), 
                       "w2", c("mean"), parallel = TRUE) 
  # w2plot$interaction <- plot.compare(interaction_adapt, bartetaNew, 
  #                                    combinationsNew, t(post.stan.full$theta), 
  #                      "w2", c("mean"), parallel = TRUE) 
  w2plot_subset$interaction <- plot.compare(interaction_adapt_subset, bartetaNew, 
                                     combinationsNew, t(post.stan.full$theta), 
                       "w2", c("mean"), parallel = TRUE) 
  w2plot_subset$gamm <- plot.compare(gamm_adapt_subset, bartetaNew, gammXNew, t(post.gamm$theta), 
                       "w2", c("mean"), parallel = TRUE) 
  w2plotData_subset <- lapply(w2plot_subset, function(i) i$data$mean)
  saveRDS( w2plotData_subset, "w2plot_bin_subset.rds" )
  w2plots_subset <- lapply(w2plot_subset, function(i) i$plot$mean)
} else {
  w2plotData_subset <- readRDS( "w2plot_bin_subset.rds" )
  w2plots_subset <- lapply(w2plotData_subset, function(ww) ggplot(ww, aes(x=nactive, y=dist, color = groups, group=groups )) +
        geom_line() + scale_color_jama() + labs(color ="Method") +
        xlab("Number of active coefficients") + ylab("2-Wasserstein Distance") + theme_bw() +
        scale_x_continuous(expand = c(0, 0)) +
        scale_y_continuous(expand = c(0, 0),
                           limits = c(0, max(ww$dist)*1.1)))
}
```


```{r mse distances new}
mseplot_subset <- list(simple=NULL,
               interaction = NULL, 
               gamm = NULL)
if (!file.exists("mseplot_bin_subset.rds")) {
  mseplot_subset$simple <- plot.compare(simple_adapt_subset, probNew, Xnew, t(post.stan$theta),
                        "mse", c("mean"), parallel = TRUE, transform = plogis)
  mseplot_subset$interaction <- plot.compare(interaction_adapt_subset, probNew, combinationsNew, t(post.stan.full$theta), 
                          "mse", c("mean"), parallel = TRUE, transform = plogis)
  mseplot_subset$gamm <- plot.compare(gamm_adapt_subset, probNew, gammXNew, t(post.gamm$theta),
                          "mse", c("mean"), parallel = TRUE,transform = plogis)
  mseplotData_subset <- lapply(mseplot_subset, function(i) i$data$mean)
  saveRDS( mseplotData_subset, "mseplot_bin_subset.rds" )
  mseplots_subset <- lapply(mseplot_subset, function(i) i$plot$mean)
  
} else {
  mseplotData_subset <- readRDS("mseplot_bin_subset.rds" )
  mseplots_subset <- lapply(mseplotData_subset, function(mm) ggplot(mm, aes(x=nactive, y=dist, color = groups, group=groups )) +
        geom_line() + scale_color_jama() + labs(color ="Method") +
        xlab("Number of active coefficients") + ylab("MSE") + theme_bw() +
        scale_x_continuous(expand = c(0, 0)) +
        scale_y_continuous(expand = c(0, 0), 
                           limits = c(0,max(mm$dist)*1.1)))
}
```

For comparison, the predicted MSE of each method is
```{r mse subset, echo=FALSE, results='asis'}
mse.best.perform_new <- data.frame(BART = mean((probNew - plogis(t(bartetaNew)))^2),
   'Simple Logistic' = mean((probNew - plogis(Xnew %*% t(post.stan$theta)))^2),
   'Logistic with Interactions' = mean((probNew - plogis(combinationsNew %*% t(post.stan.full$theta)))^2),
   GAMM = mean((probNew - plogis(gammXNew %*% t(post.gamm$theta)))^2))
rownames(mse.best.perform_new) <- "MSE"
print(xtable(mse.best.perform_new, digits=3, caption="MSE from true data generating probabilities for X[,4]<0"), type = "html")
```

```{r dist_plot_post_simple_subset, echo=FALSE, message=FALSE, warning=FALSE, fig.height= 4, fig.width=4, out.width="49%", optipng = '-o7', fig.align = "center", fig.show='hold', fig.cap='2-Wasserstein Distance and MSE for new data generated with $X[,4] < 0$ using the simple logistic regression model.'}
print(w2plots_subset$simple)
print(mseplots_subset$simple)
```

```{r dist_plot_post_interact_subset,echo=FALSE, message=FALSE, warning=FALSE, fig.height= 4, fig.width=4, out.width="49%", optipng = '-o7', fig.align = "center", fig.show='hold', fig.cap='2-Wasserstein Distance and MSE for new data generated with $X[,4] < 0$ using the logistic regression model with all twoway interactions.'}
print(w2plots_subset$interaction)
print(mseplots_subset$interaction)
```

```{r dist_plot_post_gamm_subset, echo=FALSE, message=FALSE, warning=FALSE, fig.height= 4, fig.width=4, out.width="49%", optipng = '-o7', fig.align = "center", fig.show='hold', , fig.cap='2-Wasserstein Distance and MSE for new data generated with $X[,4] < 0$ using the generalized additive mixed models model.'}
print(w2plots_subset$gamm)
print(mseplots_subset$gamm)
```
